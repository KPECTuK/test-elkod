# Тестовое задание ЭЛКОД

## Ответы на предварительные вопросы

Основная платформа .NET 5

Далее, общение с БД (PostgreSQL) идёт с помощью фреймворка EntityFramework Core (6) + расширение Snickler.EFCore  
>  общий опыт работы с реляционными БД более 4х лет из них postgre около 1.5 лет  
>  EF некоторый опыт, однако Dapper в большей степени, Sniсkler - нет опыта  

Веб-сокеты - SignalR
>  некоторый опыт работы в основном с WebSocket

Пуш-уведомления - Lib.Net.Http.WebPush
>  работал с поставщиками сервиса, такими как AppsFlyer, и найтивными мобильными реализациями Apple

Очереди сообщений - RabbitMQ
>  некоторый опыт использования, хотя непосредственно в проектировании с использованием технологии участия не принимал

Иногда мы используем холодный кэш (Redis) + горячий кэш (LazyCache)
>  использовал аналогичные embed решения, например mongo\unqlite\sqlite, использовал dynamo\cosmo

Документация к API - Swagger
>  не использовал, но работал с генераторами документации и фрейворками тестирования для C#\python\C++

Немного GraphQL
>  с библиотекой не работал, однако реализовывал парсеры по ECMA для JSON\YAML, в том числе:
>    реализовал бинарный парсер на основе AMF с расширениями и элементами GQL  
>    рефакторил NewtonJSON.NET и YAML.NET  

Авторизация - JWT токены
>  писал сервисы и использованием OAuth2 на IS4 для Core 2.0(1)

Расписания для микро-сервисов-демонов - Quartz
>  Quartz не использовал

Общение с другими сервисами по HTTP - RestSharp
>  есть опыт работы с клиентами http, c RestSharp в том числе

Логгирование в ELK-stack с помощью Serilog
>  использовал Serilog, но с ELK-stack не работал

Утилитарные библиотеки - AsyncEnumerator, morelinq, Novell.Directory.Ldap.NETStandard, System.DirectoryServices
>  использовал различные библиотеки реализации монад в том числе и для ниток, однако в связи со спецификой задач предпочитал свои решения, непосредственно администрирования Windows касался мало, знаю общую теорию AD, есть опыт администрирования Linux и приложений на базе (Debin\Arch) связанных с инфраструктурой тестирования и развертывания, есть некоторый опыт администрирования AWS

## Оригинальный текст задания

[Предоставлен в виде документа](doc.pdf). Копия текста для декомпозиции ниже.

Вам поручено реализовать новый функционал системы. База данных и код в вашем полном распоряжении.  

У компании заключены договора с Клиентами на консалтинговые услуги. В рамках договора клиенты могут присылать в компанию запросы по разным каналам(email, апи, телефон), как новые, так и уточняющие другой запрос.  

__Свойства модели Клиент:__ название, ключевитость(не ключевой, ключевой, суперключевой).  

__Свойства модели Запрос:__ тип(консультация, заказ документов), дата создания, клиент, содержание, ответ, канал(email, апи, телефон), приоритет, ссылка на модель запроса по которому прислано уточнение.  

Для оптимизации работы сотрудников в компании вводится система приоритезации запросов.  

  При создании запроса необходимо установить приоритет, определив его вес по набору критериев. Общий приоритет запроса вычисляется исходя из суммы весов каждого критерия, которому соответствует запрос.  
  Количество и вычисление критериев, как и вес могут меняться. Критерии определяются разработчиками, в каждом критерии своя логика определения подходит или нет критерий запросу.  
  Веса критериев могут меняться, в том числе пользователями(сотрудникам) и связаны с типом запроса.  

> Для примера как может выглядеть таблица весов и соответствующих им критериев по типам задач  
  >
  > |Название критерия|Вес для типа консультация|Вес для типа заказ документов
  > |-:|:-|:-|
  > |ключевой клиент|2|3
  > |суперключевой клиент|3|4
  > |первый запрос от клиента|2|2
  > |наличие уточнений от клиента|4|1

Ваша задача определить архитектуру приложения для решения поставленной задачи: 

  1. __Придумайте и схематично нарисуйте схему базы данных, по Вашему мнению, достаточную для выполнения данной задачи__

  2. __Придумайте и схематично изобразите структуру классов и методов(без реализации) для получения запроса по каналам email, апи(запрос из внешней системы), телефон(заполнение формы на сайте)__

  3. __Придумайте и схематично изобразите структуру классов и методов(без реализации) для сервиса определения приоритета запроса по критериям и весам и сервиса создания запроса с учетом многообразия каналов.__

  4. __Напишите SQL запрос, который вернет клиентов, которые хотя бы раз присылали запрос, но не присылали больше одного уточнения к запросу.__

## Декомпозиция

### Предметная область системы

В качестве списка типов приложения предложу:

  - Клиент: тип контрагента, генерирующего инциденты в систему
  - Инцидент: агрегатный абстрактный тип, отражающий связанные обращения клиента
  - Обращение: тип, описывающий результат обращения в систему со стороны клиента
  - Критерий: тип, описывающий порядок классификации обращений в системе

### Требования к функциональности

Приложение должно поддерживать возможности:

  - хранения списка клиентов пользователя
  - хранения атрибутов клиентов пользователя
  - хранения списка обращений клиентов пользователя
  - хранения атрибутов обращений клиентов пользователя
  - структурирования обращений клиентов пользователя по уточнениям в рамках инцидента
  - гарантию предоставления ответа пользователя на каждое обращение по инциденту
  - предоставление пользователю обращений клиентов в упорядоченном по приоритету виде
  - возможность создания обращений из разных источников, среди которых:
    - непосредственное обращение в API приложения
    - обращение с использованием формы
    - обращение с использованием почтового сервиса

## Решение

### Задача 1

Для хранения данных, связанных с работой приложения предлагаю использовать реляционную БД, пусть будет postgre. Предполагаемые к хранению с технической точки зрения данные, предлагаю разделить на данные предсказуемого и непредсказуемого объема. Данные с предсказуемым объемом предлагаю использовать в качестве описывающих связи и используемых для операций поиска (на схеме обозначено зеленым). Другие - как справочники, поскольку предполагаю менее интенсивное их изменение (на схеме обозначено синим).  

Предлагаю соглашение об именовании:

  - названия таблиц CamelCase с большой буквы, во множественном числе
  - названия полей сamelCase с маленькой буквы, в единственном числе
  - `id` название PK записи, если поле полностью представляет ключ
  - приставка id - для ключей
  - приставка date - для тайм стампов

Для хранения состояния приложения, предлагаю следующую схему данных:

![GitHub Light](./dbshema-light.png#gh-light-mode-only)
![GitHub Dark](./dbshema-dark.png#gh-dark-mode-only)

Таблица __Clients__: список инициаторов обращений в систему

> |имя|тип|описание|связь
> |-:|-:|-|-
> |id|uuid|идентификатор клиента|PK
> |idPriority|uuid|идентификатор в словаре привилегированности|LibClientProrities
> |name|varchar|именование|

Таблица __Requests__: таблица регистрации обращений от клиентов

> |имя|тип|описание|связь
> |-:|-:|-|-
> |id|uuid|идентификатор обращения|PK
> |idThread|uuid|идентификатор нового обращения в дереве инцидента|Requests
> |idParent|uuid|идентификатор требовавшего уточнения обращения относительно текущего (текущий - уточняющий для этой ссылки)|Requests
> |idClients|uuid|идентификатор клиента, инициировавшего обращение|Clients
> |idRequestType|uuid|идентификатор в словаре типов обращений (поскольку было упоминание в примере)|LibRequestTypes
> |idChannel|uuid|идентификатор в словаре каналов поступления|LibChannels
> |dateRequest|timestamp|время обращения клиента|
> |dateResponse|timestamp|время ответа клиенту|

Таблица __RequestProps__: таблица свойств обращения переменной длинны

> |имя|тип|описание|связь
> |-:|-:|-|-
> |id|uuid|идентификатор обращения, совпадает с идентификатором записи таблицы Requests|PK
> |contentRequest|text|текст сообщения обращения|
> |contentResponse|text|текст ответа на обращение|

Таблица __ResponseLocks__: таблица открытых обращений, является таблицей времени выполнения, может быть организована с использованием дополнительных средств кеширования такими как Redis как очередь с приоритетом, реализация зависит от нагрузки сервиса (количество одновременно открытых запросов, количество операторов), в качестве приоритета является суммарный актуальный весовой коэффициент

> |имя очереди|описание
> |-:|-
> |pending:weight|очередь задач по открытым обращениям клиентов, очередь заполняется открытыми обращениями из таблицы __Requests__ на старте приложения и далее соответственно описанию
> |acquired:weight|очередь задач по обращениям в обработке, дополнена таймаутом времени обработки

Таблица __Criterias__: таблица истории изменения весовых коэффициентов критериев

> |имя|тип|описание|связь
> |-:|-:|-|-
> |idCriteria|uuid|идентификатор критерия, задаваемый разработчиком для уникального критерия|PK
> |dateMod|timestamp|дата изменения веса критерия|PK
> |weight|int|значение весового коэффициента критерия|

Таблица __RequestCriterias__: таблица наборов критериев для обращений, записи уникальны

> |имя|тип|описание|связь
> |-:|-:|-|-
> |idCriteria|uuid|идентификатор критерия, задаваемый разработчиком для уникального критерия|Criterias
> |dateMod|timestamp|дата изменения веса критерия|Criterias
> |idRequest|uuid|идентификатор обращения для вычисления веса|Requests

Остальные таблицы справочные, служат для рендеринга данных в UI. На схеме указаны только сложные связи, направления связей ясны из названия столбцов. Все связи за исключением коммутирующей `RequestCriterias` и один к одному для `RequestProps` (обе указаны на схеме), являются связями один ко многим. Идентификаторы имеют тип `uuid` для устранения необходимости в счетчиках и облегчения шардирования, репликации и пр. FK, триггеры и индексацию, наверное можно опустить.. но тут не знаю.. это в процессе будет понятно. Ожидаемый рост в потреблении ресурсов по убыванию количества записей: RequestCriterias, Requests, RequestProps, Clients, Criterias.  

### Замечание о классификации обращений

О приоритетах обращений известно, что они вычисляются исходя из критериев. Критерии и их отношения к обращениям вводятся разработчиками, то-есть отождествление с идентификатором и реализация - это область ответственности разработчика. Обеспечения в системе возможности добавления и идентификации критериев будет достаточно для сопровождения приложения. Однако значения критериев (весовые коэффициенты) задаются пользователями, в следствие чего, для обращения могут быть рассчитаны разные суммарные весовые коэффициенты в моменты времени до и после редактирования их для отдельных критериев. Следовательно, для сохранения целостности данных и в виду отсутствия уточнения в задании по этому вопросу, целесообразно ввести историю изменения весовых коэффициентов для критериев.  

В реализации, в процессе создания обращения, ему сопоставляется ряд критериев, веса из которых вычисляются, как значения наиболее младших записей таблицы критериев (__Criterias__). Это соответствие записывается в таблицу критериев обращения (__RequestCriterias__). Таким образом в базе хранятся версии весовых коэффициентов, обеспечивающие расчет значения итогового коэффициента для каждого обращения на момент создания обращения. В этой связи необходимо соблюдение условия касающееся неизменности идентификатора для критерия. Так же возможна ситуация, при которой поведение системы будет не очевидным, если реализация не будет учитывать эту особенность (версии коэффициентов) в связи с чем, этот вопрос в не рамок тестового задания требует отдельного уточнения. В прочем, данная реализация позволяет рассчитать оба значения: как актуальное так и историческое.  

Подчеркну, что поскольку критерии предполагаются к реализации на стороне БД, изменение реализации критерия в процессе обновления приложения предполагает критерий отличным от предыдущей версии. Следовательно новая версия будет новым критерием с новым идентификатором. Для реализации критерия возможно применение "не доверенного" языка, по этому, вопросу выбора и реализации необходимо уделить дополнительное внимание. Реализация на стороне БД предпочтительна, ввиду сохранения целостности данных и атомарности обращения к БД.

### Задача 2

Для реализации сервиса предлагаю использовать Core.Kestrel. Реализация модуля сервиса в этом случае может выглядеть как композиция вида:

  - Сервис логирования: обеспечение ведения журнала логов модуля
  - Сервис соединения с БД: обеспечение поддержания соединения с БД
  - Сервис парсера почтовых сообщений: обеспечение опроса и инициации создания обращений по почтовым сообщениям
  - Контроллер реализации API: обеспечение сопровождения HTTP запросов в приложение
  - Страница создания клиента: UI пользователя приложения
  - Страница создания обращения: UI пользователя или потребителя услуги пользователя приложения
  - Страница завершения обращения: UI пользователя приложения
  - Страница изменения весового коэффициента критерия: UI пользователя приложения

Сервисы в зависимости от требований к масштабируемости приложения, так же могут представлять из себя отдельные модули. Например сервис парсера почтовых сообщений может работать через API контроллера в backend.  

Для обеспечения целостности данных, доступ к данным предлагаю осуществлять через хранимые процедуры на стороне БД, полезную нагрузку среди которых осуществляют:

  - процедура создания клиента
  - процедура создания обращения
  - процедура выборки обращения
  - процедура завершения обращения
  - процедура получения списка дескрипторов доступных критериев
  - процедура создания записи весового коэффициента критерия
  - процедуры вычисления применимости критериев

 Основные конечные точки API:

Процесс сопровождения __создания обращения__ может выглядеть как (вставка, без коллизий):

  - инициация обращения путем создания контейнера данных обращения через:
    - обращение к API непосредственно (основной метод)
    - обращение к API через страницу формы
    - обращение к API через сервис парсера почтовых сообщений в случае если он запущен отдельно (или любой другой, возможно по расписанию)
    - инициация создания обращения через создание контейнера данных обращения в модуле
  - валидация контейнера данных обращения
  - сохранение обращения с использованием данных контейнера через процедуру БД, реализующую:
    - обход методов применения критериев, возвращающих:
      - идентификатор в случае применимости
      - признак не применимости в противном случае
    - вычисление актуального весового коэффициента
    - добавление записей таблицы __RequestCriteria__ для каждого из применимых критериев
    - добавление записи таблицы __Requests__
  - добавление в очередь ожидания ответа __ResponseLocks:pending:weight__
  - возврат состояния процесса

Процесс сопровождения __изменения весового коэффициента__ может выглядеть как (вставка, без коллизий):

  - инициация процесса путем создания запроса к API изменения весового коэффициента через форму, для чего:
    - выполнить вызов процедуры БД для получения списка дескрипторов критериев
  - выполнить валидацию контейнера данных запроса на изменение
  - вызов процедуры добавления записи весового коэффициента для критерия через процедуру в БД
  - возврат состояния процесса

Процесс сопровождения __получения оператором обращения для ответа__ может выглядеть как:

  - инициация процесса через запрос страницы формы ответа
  - вызов процедуры получения дескриптора обращения для заполнения формы, через процедуру БД, реализующую:
    - получение идентификатора запроса по задаче из очередей __ResponseLocks:pending:weight__, с наименьшим весовым коэффициентом, перемещение задачи в соответствующую очередь __ResponseLocks:acquired:weight__
      - в случае успеха продолжать на уровне выше
      - получение идентификатора запроса по задаче из очередей __ResponseLocks:acquired:weight__ с наименьшим весовым коэффициентом и таймаутом по __dateReject__
        - в случае успеха перемещение задачи в соответствующую очередь __ResponseLocks:pending:weight__ и повтор процедуры
    - получение дескриптора обращения по идентификатору или пустого дескриптора в случае отсутствия идентификатора
    - возврат результирующего дескриптора
  - возврат состояния процесса и контейнера данных обращения с форме ответа

Процесс сопровождения __отправки оператором ответа на обращение__ может выглядеть как:

  - инициация процесса через запрос формой данных ответа
  - вызов процедуры добавления ответа через процедуру БД:
    - отклонение ответа в случае отсутствия задачи в очереди __ResponseLocks:acquired:weight__ или таймаута по __dateReject__
    - обновление записей в __Requests__, __RequestProps__
  - уведомление клиента о получении ответа на обращение в случае успешного внесения ответа в БД

### Задача 3

В задаче предполагается наверное, что бизнес логика целиком реализована в рамках модуля сервиса. Однако с учетом использования Redis в качестве очереди задач управления операторами и postgre в качестве основного хранилища, предпочел бы разделить реализацию и использовать например python для реализации критериев и коммуникации с Redis. Это на мой взгляд могло бы:

  - сократить количество запросов в backend
  - снизить количества запросов от сервиса в БД
  - упростить тестирование за счет отсутствия связности между критериями, тем более что они в любом случае, входят в область ответственности разработчика
  - предоставить больше данных об обращении и его контексте в окружении БД, для функция критерия
  - устранить необходимость в универсальном протоколе предоставления данных для вычисления критерия
  - разделить систему на более мелкие компоненты, что упростит тестирование и положительно скажется на масштабируемости приложения
  - есть еще идея реализовать обращение к Redis из процедур БД.. звучит дико и скорее всего идея не удачная, но попробовать хочется, в некотором окружении это может быть вариантом

На Redis я наверное настоял бы, т.к. есть задача реализации конкурентной очереди с приоритетом, а RabbitMQ поддерживает только 255 ключей приоритета, этого может оказаться не достаточно. В Redis такого ограничения нет, но может быть я плохо знаю RabbitMQ. Кроме того в задаче нет требований к технологиям, а даже и наоборот. Python я выбрал просто потому что на нем могу, хотя он в postgre "не доверенный". Это так же вопрос для обсуждения за рамками тестирования. Реализация критерия на python могла бы выглядеть так:

``` pl
CREATE FUNCTION py_criteria_never (idRequest uuid)
  RETURNS uuid
AS $$
  # критерий приведен в качестве примера и не валиден для всех типов запросов by design
  # ниже, определенный для критерия постоянный идентификатор
  idCriteria = uuid.uuid4()
  # можно так же и имя возвращать, используя данные для патчей
  nameCriteria = 'name'
  # функция должна работать в двух режимах:
  # режим проверки запроса: для валидации критериея для запроса
  # режим эха: для получения или валидации списка доступных идентификаторов критериев
  return idCriteria, nameCriteria if idRequest is None else None, nameCriteria
$$ LANGUAGE plpythonu;
```

Функция, возвращающая валидные критерии для обращения могла бы выглядеть так:

``` pl
CREATE FUNCTION py_get_criterias (idRequest uuid)
  RETURNS uuid[]
AS $$
  plan = pypl.prepare('SELECT id, name FROM LibCriterias')
  return [record for record in pypl.execute(plan) if not getattr(record.name)(idRequest)[0] is None]
$$ LANGUAGE plpythonu;
```

Решение предлагается как грубое описание варианта реализации задачи, достаточное для производства прототипа. Тоже самое можно сделать исключительно для C# с использованием MSSQL и наверное Redis (у него есть клиент для C#). В описании возможны неточности однако кардинально по моему не влияющие на возможность реализации идеи. Я не предложил композицию типов модуля, поскольку ее прикладная часть в реализации выглядит тривиальной и класса контроллера с реализацией API для нее достаточно. Для связывания сервисов можно использовать контейнер зависимостей Core и наверное два типа в качестве контейнеров данных для сериализации и хранения данных в рамках запроса к API:

  - `DataCriteria`: для использования с запросом создания весового коэффициента
  - `DataRequest`: для использования с запросами сопровождения обращений клиента

Оба в большей степени отражают соответствующие таблицы БД. Так же могут понадобиться библиотеки:

  - парсера JSON например `Newtonsoft.Json`
  - логирования, например `Serilog`
  - подключения к БД `NpgSQL`
  - меппер, например `Dapper` или `EF`
  - возможно тестирования, например `NUnit`, в случае реализации полностью на C#

### Задача 4

Запрос реализован с использованием поля idThread таблицы Requests. Предполагается, что поле для всех обращений (записей) содержит идентификатор корневого обращения и для корневого обращения его значение равно `id` этой же записи. Клиент, обращавшийся к пользователю будет иметь хотя бы одну запись. Группировка по этому полю позволит исключить количество обращений по инциденту по заданному критерию: не больше двух то есть хотя бы одно уточнение. В выборку попадут клиенты обращавшиеся или обращавшиеся и уточнявшие один раз.

``` sql
SELECT idClient, [name]
FROM (
  SELECT DISTINCT q.idClient AS idClient
  FROM Requests AS q 
  GROUP BY q.idClient, q.idThread
  HAVING COUNT( q.idThread ) < 3 ) AS r
JOIN Clients c
ON c.id = r.idClient
```
